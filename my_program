#!/usr/bin/env ruby

require 'tty-prompt'
require_relative 'lib/vendors/string'
require_relative 'lib/parking_lot'

WHITELIST_COMMANDS = %(create_parking_lot park leave status plate_numbers_for_cars_with_colour slot_numbers_for_cars_with_colour slot_number_for_registration_number).freeze

# args
Dir.glob(File.expand_path('lib/args/*.rb', __dir__)).each do |file|
  require_relative file
end

parking_lot = ParkingLot.new

File.readlines(ARGV[0]).each do |line|
  begin
    raw_input = line
    input = raw_input.split
    cmd = input[0]

    next unless WHITELIST_COMMANDS.include?(cmd)
    break if cmd.downcase == 'exit'

    klazz = Object.const_get("#{cmd}_args".classify)
    args = klazz.new(input[1..-1]).args

    result = args.nil? ? parking_lot.send(cmd) : parking_lot.send(cmd, args)
    puts parking_lot.send("#{cmd}_say".to_sym, result)
  rescue => e
    puts e.message
  end
end

prompt = TTY::Prompt.new
# loop do
#   begin
#     raw_input = prompt.ask('Input:')
#     input = raw_input.split
#     cmd = input[0]

#     break unless WHITELIST_COMMANDS.include?(cmd)

#     klazz = Object.const_get("#{cmd}_args".classify)
#     args = klazz.new(input[1..-1]).args

#     result = args.nil? ? parking_lot.send(cmd) : parking_lot.send(cmd, args)
#     prompt.say(parking_lot.send("#{cmd}_say".to_sym, result))
#   rescue StandardError => e
#     prompt.say(e.message)
#   end
# end
